
Afin de réaliser notre analyse, nous avons procédé en deux étapes.
Tout d'abord nous avons défini un modèle mathématique permettant d'estimer le coût d'une attaque et de la défense.
Puis nous avons appliqué notre modèle en analysant des jeux de données.
Dans cette section, nous expliquerons tout d'abord notre modèle mathématiques puis nous expliquerons comment nous avons appliqué ce modèle à nos données.
%grandeur concernant la biodiversité du système.


\subsection{Analogie avec la thermodynamique}

Afin de définir notre modèle mathématique, nous avons basé notre approche sur un phénomène physique homologue : la thermodynamique.
Nous allons donc définir une entropie logicielle qui sera liée à l'hétérogénéité du système.
Redéfinissons tout d'abord le premier principe de la thermodynamique~: Il y a conservation de l'énergie. 

\[
\Delta E = \Delta U = W + Q
\]

$\Delta E$ est la variation d'énergie du système, $\Delta U$ est la variation d'énergie interne du système, $W$ est le travail reçu par le système et $Q$ est la chaleur reçue par le système.

La seconde loi de la thermodynamique nous donne :
\[
S_{creation} = \Delta S_{syst} + \Delta S_{ext} \geq 0
\]

Cela se caractérise dans notre cas par un principe simple~: tout changement de configuration dans notre système, quel qu'il soit, crée de l'entropie et donc augmente, au moins temporairement, la difficulté de l'attaque.
Dans le cas ou l'entropie de notre système diminuerai, il y a tout de même une augmentation de l'entropie du côté de l'attaquant. Cela s'explique par le fait que l'état du nouveau système lui est inconnu. Il doit à nouveau refaire toute son analyse avant d'effectuer une nouvelle attaque. On notera également que sans action spécifique du défenseur, en laissant les administrateurs des sous-systèmes faire les mises à jour indépendamment, l'entropie du système global va augmenter de manière naturelle au cours du temps. 

Le second principe peut également s'écrire :

\[
\frac{Q}{T} \leq \Delta S_{syst}
\]

À quoi correspondent toutes ces grandeurs physiques dans notre système ? On va associer Q à l'effort fourni pour effectuer des mises à jours (Si Q est nul, il n'y a pas d'entropie créée), et W sera le travail fourni par l'attaquant pour effectuer son attaque. Du côté du défenseur, Q va en réalité être négatif. En effet, on va associer l'énergie du système à la quantité d'attaques subies. On veut donc en permanence le "refroidir".
De même, la température T va être associée à la vulnérabilité des versions des logiciels du système. Plus les versions sont anciennes, plus elles seront vulnérables et donc la température va augmenter en fonction du temps.
On notera également que plus l'entropie du système est grande, plus le travail à fournir par l'attaquant sera important.

\subsection{Modèle mathématique}\label{sec:modelMath}

\subsubsection{Modèle basé sur la théorie des jeux}

Voici les coûts pour l'attaquant pour attaquer respectivement une version donnée et toutes les versions du logiciel présentes sur les différentes machines du système ~:

\[
	C_{version} = \sum_{vulnerabiltes} C_{vulnerabilite}
\]

La façon dont les données sur les vulnérabilités ont été extraites est expliquée à la section \ref{sec:recupData}.  $C_{vulnerabilte}$ représente le coût d'exploitation de chaque vulnérabilité, que ce soit par l'achat d'un exploit ou sa conception.
 
\[
	C_{total} = \sum_{versions} C_{version} - k *\sum_{i,j,i \neq j} C_{vulnerabilitesCommunes}
\]




\subsubsection{Modèle basé sur des équations différentielles}

Voici les coûts pour l'attaquant pour attaquer respectivement une version donnée et toutes les versions du logiciel présentes sur les différentes machines du système ~:

\[
	C_{version} = k*e^{- \lambda t}
\]

\[
	C_{total} = U * M_{c} * V_{couts}
\]

Avec U le vecteur unitaire, $M_c$ la matrice de corrélation des failles entre les différentes versions d'un système et $V_{couts}$ le vecteur des coûts de l'attaque pour les différentes versions du système.
On considère que le coût pour attaquer une version d'un système décroit exponentiellement au cours du temps (de nouvelles failles sont découvertes et de nouveaux exploits sont publiés). Le coût total pour attaquer toutes les versions présentes sur le système n'est pas exactement la somme des coûts d'attaque de chaque version, car certaines failles sont présentes dans plusieurs versions : cette différence est prise en compte grâce à $M_c$ , la matrice de corrélation.


\subsection{Application du modèle}\label{sec:simulation}
Dans cette section, nous expliquons comment nous avons appliqué notre modèle mathématiques.
Nous avons dans un premier temps récupérer les données des différentes versions de serveur Web utilisés par les communes françaises ainsi que des vulnérabilités associées.
Finalement nous avons recoupé les différentes information et effectué le calcul mathématiques.

\subsubsection{Récupération des données}\label{sec:recupData}
Pour faire une études comparative, nous avons récupéré un jeu de donnée sur les serveurs web utilisés par les communes françaises datant de mars 2015.
Par la suite, nous avons généré un jeu de donnée à partir du même script afin de connaître l'état actuel des systèmes.
Finalement nous avons récupéré les différentes failles de sécurité connu pour les différentes version de ces logiciels.

Les différentes failles de sécurité ont été récupéré depuis la base de donnée de vulnérabilité du gouvernement américain~\cite{vulnDatabase} qui contient des vulnérabilités recensés depuis 2002.
Les informations que nous avons récupéré nous permettent pour chaque vulnérabilité de savoir le logiciel et les différentes version qui y sont sensibles.


Une fois les données trouvée, nous avons réalisé un recoupement des données.
Pour cela, nous avons considéré que les versions de logiciel donnés par les serveurs sont les versions réellement utilisés et également que les serveur n'envoyant pas d'informations sont sécurisé de base.


\subsubsection{Application du modèle mathématique}
Notre modèle mathématique prend en compte d'une part la variabilité des différents systèmes dans l'environnement ainsi que les mises à jours.
En effet, nous avons précédemment expliqué qu'une mise à jours amenait un travail supplémentaire à fournir par l'attaquant.
Nous appliquons donc simulation, une où l'on considère la complexité de l'attaque liée à l'hétérogénéité du système et une où l'on considère l'impact des mises à jours sur l'entropie.

\paragraph{L'impact de l'hétérogénéité du système}
Le fait d'avoir un système hétérogène amène à une augmentation du nombre total de vulnérabilité.
Cependant cette diversité peut rend une attaque global plus complexe vue que chacun des systèmes sera sensible à des attaques différentes.
La figure~\ref{fig:heteImpactVuln} exprime cette notion de non concordance entre les vulnérabilités et leur version.
Dans cette figure, les nœuds "Ln" représentent une version de logiciel et les noeuds "Vn" représentent un numéro de vulnérabilité.
Nous voyons que certaine version n'ont aucune vulnérabilité communes avec d'autre tel que "L4" avec et "L5".
Dans ce cas, il est plus compliqué d'attaquer les deux système simultanément.
Cependant, si nous prenons le cas de "L1" et "L2", ils sont tout deux sensibles à "V1" et "V2".
Dans ce cas, la diversité amène une augmentation du risque d'attaques.


\begin{figure}
\centering
%peut être la faire avec des exemple de vulnérabilité réelles
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
  thick,version node/.style={circle,fill=blue!15,draw,
  font=\sffamily\small\bfseries,minimum size=5mm}, vulne node/.style={circle,fill=red!15,draw,
  font=\sffamily\small\bfseries,minimum size=5mm}]
  
  \node[version node] (L0) {L1};
  \node[version node] (L1) [below of=L0] {L2};
  \node[version node] (L2) [below of=L1] {L3};
  \node[version node] (L3) [below of=L2] {L4};
  \node[version node] (L4) [below of=L3] {L5};
  
  \node[vulne node] (V1) [right of=L0, node distance=3cm] {V1};
  \node[vulne node] (V2) [below of=V1] {V2};
  \node[vulne node] (V3) [below of=V2] {V3};
  \node[vulne node] (V4) [below of=V3] {V4};
  \node[vulne node] (V5) [below of=V4] {V5};

%connexion vulnerabilité 1
  \draw [-latex'] (V1) -- (L0);
  \draw [-latex'] (V1) -- (L1);
  \draw [-latex'] (V1) -- (L2);
  \draw [-latex'] (V1) -- (L4);
  
%connexion vulnerabilité 2
  \draw [-latex'] (V2) -- (L0);
  \draw [-latex'] (V2) -- (L1);
  \draw [-latex'] (V2) -- (L2);

%connexion vulnerabilité 3
  \draw [-latex'] (V3) -- (L0);
  \draw [-latex'] (V3) -- (L2);

%connexion vulnerabilité 4
%  \draw [-latex'] (V4) -- (L4);
  \draw [-latex'] (V4) -- (L2);
  \draw [-latex'] (V4) -- (L3);

%connexion vulnerabilité 5
  \draw [-latex'] (V5) -- (L4);
 
  
\end{tikzpicture}
\caption{Schéma de la relation entre la version d'un logiciel et les vulnérabilités associées.}
\label{fig:heteImpactVuln}
\end{figure}

Pour analysé cette impact, nous considérons deux éléments, le nombre total $T$ de vulnérabilités du système ainsi que le nombre minimum $M$ de vulnérabilité nécessaires pour contaminé entièrement le système.
$T$ permet d'estimer la probabilité qu'un attaquant possède un exploit, plus ce nombre est élevé et plus la probabilité est grande.
$M$ permet d'estimer la complexité pour l'attaquant si il veut attaquer tout les ordinateur du système.
Plus ce nombre est élevé, plus la difficulté est importante.

\paragraph{L'impact des mises à jours}
Dans le paragraphe précédent, nous avons expliqué l'intérêt qu'il y a à la diversité des versions.
Toutefois, nous n'avons pas pris en compte l'ancienneté d'une vulnérabilité. 
L'ancienneté d'une vulnérabilité la rend plus facilement exploitable car plus connu.
De plus, comme expliqué dans la section~\ref{sec:modelMath}, le fait de faire des mises à jours forcera l'attaquant à augmenter l'effort pour être capable de s'adapter à ce changement.

Pour évaluer l'impact de l'ancienneté d'une version, nous ajoutons une majoration à la probabilité que l'attaquant possède une vulnérabilité.
En effet il est peu probable qu'un attaquant possède un exploit pour une vulnérabilité récente alors qu'il est bien plus facile pour lui d'en obtenir un pour une ancienne vulnérabilité.
Finalement, nous sommes capable d'estimer l'effort nécessaire pour un attaquant pour déterminer les différentes versions de logiciel utilisés lors d'une mise à jours.

